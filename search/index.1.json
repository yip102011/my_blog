[{"content":"Hello, I am a software engineer working on backend development and devops.\nHere is my GitHub.\n","date":"November 15, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/hugo-theme-bootstrap-skeleton/about/","smallImg":"","tags":[],"timestamp":1668470400,"title":"About"},{"content":"如何使用私錀登入 Linux\nSSH - 使用私錀登入# 生成一對公鑰和私鑰 # works on linux and windows ssh-keygen ls ~/.ssh 預設生成在 ~/.ssh，id_rsa 是私鑰，id_rsa.pub 是公鑰\nid_rsa id_rsa.pub\n上傳公鑰到伺服器 # only for linux ssh-copy-id username@remote_host 如果使用 windows，打開 cmd，使用 scp 上傳金鑰\n# only for cmd scp %USERPROFILE%/.ssh/id_rsa.pub isaac@192.168.0.100:~/tmpe_id_rsa.pub ssh isaac@192.168.0.100 \u0026#34;mkdir -p ~/.ssh \u0026amp;\u0026amp; cat ~/tmpe_id_rsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys \u0026amp;\u0026amp; rm ~/tmpe_id_rsa.pub\u0026#34; 以上命令會把公鑰上傳到伺服器的檔案 ~/.ssh/authorized_keys。\n3.現在登入不用密碼了\nssh isaac@192.168.0.100 ","date":"October 3, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/hugo-theme-bootstrap-skeleton/blog/ssh_login_by_key/","smallImg":"","tags":[{"title":"ssh","url":"/hugo-theme-bootstrap-skeleton/tags/ssh/"},{"title":"linux","url":"/hugo-theme-bootstrap-skeleton/tags/linux/"}],"timestamp":1664755200,"title":"SSH - 使用私錀登入"},{"content":"如何使用 openssl 生成 TLS 需要的憑證\n使用 openssl 生成 TLS 憑證# 生成自簽伺服器證書# openssl req -x509 -nodes -newkey rsa:2048 \\ -subj=\u0026#39;/CN=Self Sign Cert\u0026#39; \\ -extensions usr_cert \\ -addext \u0026#34;keyUsage = nonRepudiation, digitalSignature, keyEncipherment\u0026#34; \\ -addext \u0026#34;extendedKeyUsage = serverAuth\u0026#34; \\ -addext \u0026#34;subjectAltName = DNS:www.server.com,DNS:localhost,IP:127.0.0.1\u0026#34; \\ -out=crt.pem -keyout=key.pem 生成完整憑證鏈# 生成自簽根憑證 Generate self sign root CA cert# # 生成私鑰 # generate private key openssl genrsa -out=root_ca_key.pem 2048 # 用私鑰生成根憑證 # generate root cert from private key openssl req -x509 -sha256 -new -days=10950 \\ -subj=\u0026#39;/CN=Root CA/C=HK/L=Hong Kong\u0026#39; \\ -addext \u0026#34;keyUsage = critical, keyCertSign, cRLSign\u0026#34; \\ -key=root_ca_key.pem -out=root_ca_crt.pem # 生成流水號，每次簽發證書，流水號會加一 # create root ca serial number file, this will record how many cert this ca issued openssl rand -hex -out=root_ca_srl.txt 20 # 檢查憑證訊息 # check cert info openssl x509 -in root_ca_crt.pem -text 生成中間憑證 Issue intermediate CA cert# # 憑證配置 # cert config tee inter_ca_ext.cnf \u0026lt;\u0026lt;EOF [inter_ca_ext] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = critical, CA:TRUE, pathlen:0 keyUsage = critical, keyCertSign, cRLSign EOF # 生成私鑰 # generate private key openssl genrsa -out=inter_ca_key.pem 2048 # 生成 CSR # generate CSR (Certificate Signing Request) openssl req -sha256 -new -subj=\u0026#39;/CN=Intermediate CA/C=HK/L=Hong Kong\u0026#39; \\ -key=inter_ca_key.pem -out=inter_ca_csr.pem # 簽發中間憑證 # issue intermediate ca with root ca openssl x509 -req -days=1095 -CAserial=root_ca_srl.txt \\ -CA=root_ca_crt.pem -CAkey=root_ca_key.pem \\ -extfile=inter_ca_ext.cnf -extensions=inter_ca_ext \\ -in=inter_ca_csr.pem -out=inter_ca_crt.pem # 生成流水號，每次簽發證書，流水號會加一 # create root ca serial number file, this will record how many cert this ca issued openssl rand -hex -out=inter_ca_srl.txt 20 # 檢查憑證訊息 # check cert info openssl x509 -in inter_ca_crt.pem -text 生成伺服器憑證 Generate Server Cert# # 憑證配置 # cert config tee server_ext.cnf \u0026lt;\u0026lt;EOF [server_ext] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer basicConstraints = critical, CA:FALSE keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = critical, serverAuth subjectAltName = @server_ext_san [server_ext_san] DNS = nginx.test.isaac.com DNS = localhost IP = 127.0.0.1 EOF # 生成私鑰 # generate private key openssl genrsa -out=server_key.pem 2048 # 生成 CSR openssl req -sha256 -new -subj \u0026#34;/CN=Server Cert/C=HK/L=Hong Kong\u0026#34; \\ -key=server_key.pem -out=server_csr.pem # 簽發伺服器憑證 # issue server cert with intermediate ca openssl x509 -req -days=365 -CAserial=inter_ca_srl.txt \\ -CA=inter_ca_crt.pem \\-CAkey=inter_ca_key.pem \\ -extfile=server_ext.cnf -extensions=server_ext \\ -in=server_csr.pem -out=server_crt.pem # 檢查憑證訊息 # check cert info openssl x509 -in server_crt.pem -text 生成客戶端憑證 Generate Client Cert# # 憑證配置 # cert config tee client_ext.cnf \u0026lt;\u0026lt;EOF [client_ext] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer basicConstraints = critical, CA:FALSE keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = critical, clientAuth EOF # 生成私鑰 # generate private key openssl genrsa -out=client_key.pem 2048 # 生成 CSR openssl req -sha256 -new -subj \u0026#34;/CN=Client Cert/C=HK/L=Hong Kong\u0026#34; \\ -key=client_key.pem -out=client_csr.pem # 簽發客戶端憑證 # issue client cert with intermediate ca openssl x509 -req -days=365 -CAserial=inter_ca_srl.txt \\ -CA=inter_ca_crt.pem \\-CAkey=inter_ca_key.pem \\ -extfile=client_ext.cnf -extensions=client_ext \\ -in=client_csr.pem -out=client_crt.pem # 檢查憑證訊息 # check cert info openssl x509 -in client_crt.pem -text 其他實用命令# 下載伺服器憑證# echo -n | openssl s_client -connect www.google.com:443 | openssl x509 \u0026gt; google_crt.pem 下載憑證鏈# openssl s_client -showcerts -verify 5 -connect www.google.com:443 \u0026lt; /dev/null | awk \u0026#39;/BEGIN CERTIFICATE/,/END CERTIFICATE/{ if(/BEGIN CERTIFICATE/){a++}; out=\u0026#34;cert_chain.pem\u0026#34;; print \u0026gt;out}\u0026#39; 增加信任憑證# ubuntu\nsudo apt-get install -y ca-certificates sudo cp ca.crt /usr/local/share/ca-certificates sudo update-ca-certificates powershell\nImport-Certificate -FilePath \u0026#34;C:\\crt.pem\u0026#34; -CertStoreLocation cert:\\CurrentUser\\Root Import-Certificate -FilePath \u0026#34;C:\\crt.pem\u0026#34; -CertStoreLocation Cert:\\LocalMachine\\Root docker ubuntu container\ndocker run --rm -it \\ -v=/my_certs/root_crt.pem:/etc/ssl/certs/root_crt.pem \\ wbitt/network-multitool bash 加密/解密私鑰# # 生成 RSA 私鑰 openssl genrsa -out=rsa_key.pem 2048 # 將私鑰轉換 pkcs8 格式 openssl pkcs8 -topk8 -in rsa_key.pem -out key.pem -nocrypt # 加密私鑰 openssl pkcs8 -topk8 -in key.pem -out key_encrypt.pem # 解密私鑰 openssl pkcs8 -topk8 -in key_encrypt.pem -out key_decrypt.pem 格式轉換# ## 生成自簽證書 openssl req -x509 -nodes -newkey rsa:2048 -subj=\u0026#39;/CN=Self Sign Cert\u0026#39; -out=crt.pem -keyout=key.pem ## PEM 轉 PFX openssl pkcs12 -in=crt.pem -inkey=key.pem -export -out=crt.pfx ## PFX 轉 PEM openssl pkcs12 -in=crt.pfx -out=crt_key.pem -nodes ## PEM 轉 DER openssl x509 -outform der -in crt.pem -out crt.der ## DER 轉 PEM openssl x509 -inform der -in crt.der -out crt_from_der.pem ## PKCS#8 轉 PKCS#1 openssl rsa -in key.pem -out key_pkcs1.pem 參考資料# https://www.openssl.org/docs/man1.1.1/man1/ https://www.openssl.org/docs/man1.1.1/man5/x509v3_config.html https://datatracker.ietf.org/doc/html/rfc5280 https://en.wikipedia.org/wiki/PKCS ","date":"May 1, 2022","img":"/hugo-theme-bootstrap-skeleton/blog/openssl_create_cert/thumbnail.png","lang":"zh-hk","langName":"繁體中文","largeImg":"/hugo-theme-bootstrap-skeleton/blog/openssl_create_cert/thumbnail_hub6c4f78935da036f40ac595842e2051c_19420_500x0_resize_box_3.png","permalink":"/hugo-theme-bootstrap-skeleton/blog/openssl_create_cert/","smallImg":"/hugo-theme-bootstrap-skeleton/blog/openssl_create_cert/thumbnail_hub6c4f78935da036f40ac595842e2051c_19420_180x0_resize_box_3.png","tags":[{"title":"openssl","url":"/hugo-theme-bootstrap-skeleton/tags/openssl/"},{"title":"tls","url":"/hugo-theme-bootstrap-skeleton/tags/tls/"}],"timestamp":1651363200,"title":"OpenSSL - 使用 Openssl 生成 TLS 憑證"},{"content":"教你使用 Proxy 跟 HTTPS 的 3 種模式\n如何在 K8S 設定 HTTPS# 使用 Proxy 跟 HTTPS 的 3 種模式# TLS termination# nginx 把 HTTP 解密後以明文方或傳送到後方。\n設定方便，只需設定 nginx 安全性較低 TLS passthrough# nginx 不進行解密，用 TCP protocol 傳送資料到 API。\n由於 nginx 不解密，部份功能無法使用，例如修改 HTTP Header，把內容傳送到 log 系統等等 安全性比 TLS termination 高 TLS termination + TLS backend# nginx 把 HTTP 解密後，再使用 TLS 加密才傳送到後方，兩段 HTTPS。\n安全性比 TLS termination 高，比 TLS passthrough 低 nginx 可以進行解密，並使用修改 HTTP Header，log 等功能 設定繁瑣 建立 Namespace# kubectl create namespace sandbox kubectl config set-context --current --namespace=sandbox 準備憑證 Prepare Certificate# 安裝 cert manager kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml 建立 Self Sign Root CA cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: cert-manager.io/v1 kind: Issuer metadata: namespace: sandbox name: selfsigned-issuer spec: selfSigned: {} --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: namespace: sandbox name: root-ca spec: isCA: true commonName: Root CA secretName: root-ca usages: - signing - cert sign - crl sign privateKey: encoding: PKCS8 algorithm: ECDSA size: 256 issuerRef: name: selfsigned-issuer --- apiVersion: cert-manager.io/v1 kind: Issuer metadata: namespace: sandbox name: root-ca-issuer spec: ca: secretName: root-ca EOF 建立 Intermediate CA cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: cert-manager.io/v1 kind: Certificate metadata: namespace: sandbox name: inter-ca spec: isCA: true commonName: Intermediate CA secretName: inter-ca usages: - signing - cert sign - crl sign privateKey: encoding: PKCS8 algorithm: ECDSA size: 256 issuerRef: name: root-ca-issuer --- apiVersion: cert-manager.io/v1 kind: Issuer metadata: namespace: sandbox name: inter-ca-issuer spec: ca: secretName: inter-ca EOF 建立 Nginx 伺服器憑證 Nginx Server Cert cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: cert-manager.io/v1 kind: Certificate metadata: namespace: sandbox name: nginx-server-cert spec: isCA: false secretName: nginx-server-cert commonName: Nginx Server Cert dnsNames: - localhost - test-nginx-server.com - test-nginx-api-server.com usages: - digital signature - key encipherment - server auth privateKey: encoding: PKCS8 algorithm: ECDSA size: 256 issuerRef: name: inter-ca-issuer EOF 建立 API 伺服器憑證 API Server Cert cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: cert-manager.io/v1 kind: Certificate metadata: namespace: sandbox name: api-server-cert spec: isCA: false secretName: api-server-cert commonName: API Server Cert dnsNames: - localhost - test-api-server.com usages: - digital signature - key encipherment - server auth privateKey: encoding: PKCS8 algorithm: ECDSA size: 256 issuerRef: name: inter-ca-issuer EOF 可以看到已經建立了 4 個 tls secret kubectl get secret | grep tls api-server-cert kubernetes.io/tls inter-ca kubernetes.io/tls nginx-server-cert kubernetes.io/tls root-ca kubernetes.io/tls 將 Root CA 加入信任名單 # download ca cert from k8s secret kubectl get secret root-ca -o go-template=\u0026#39;{{index .data \u0026#34;ca.crt\u0026#34;|base64decode}}\u0026#39; \u0026gt; root_ca.crt # add to trusted list sudo cp root_ca.crt /usr/local/share/ca-certificates sudo update-ca-certificates 部署 api service and nginx# # deploy api service kubectl apply -f https://raw.githubusercontent.com/yip102011/isaac_test_api/master/k8s_deploy/k8s_deploy.yaml # deploy nginx kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/cloud/deploy.yaml 部署 Ingress (TLS termination)# cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: tls-termination-ingress spec: ingressClassName: nginx tls: - hosts: - test-nginx-server.com secretName: nginx-server-cert rules: - host: test-nginx-server.com http: paths: - path: / pathType: Prefix backend: service: name: test-api port: number: 80 EOF 查看連接憑證 # 查看連接憑證 echo | openssl s_client -servername test-nginx-server.com -connect 127.0.0.1:443 | grep CN # 查看憑證詳細資料 echo | openssl s_client -servername test-nginx-server.com -connect 127.0.0.1:443 | openssl x509 -inform pem -noout -text # 可以看到已經在使用 nginx server cert 訪問 API curl --resolve test-nginx-server.com:127.0.0.1 https://test-nginx-server.com/hello Hello World!\n部署 Ingress (TLS passthrough)# # 增加 --enable-ssl-passthrough 到 container args kubectl patch deployments.apps ingress-nginx-controller -n ingress-nginx --type=json -p=\u0026#39;[{\u0026#34;op\u0026#34;: \u0026#34;add\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/spec/template/spec/containers/0/args/-\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;--enable-ssl-passthrough\u0026#34; }]\u0026#39; # 注意這次增加了 annotations # host 改成 test-api-server.com # 後台使用 443 連接 API cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: tls-passthrough-ingress annotations: nginx.ingress.kubernetes.io/ssl-passthrough: \u0026#34;true\u0026#34; spec: ingressClassName: nginx rules: - host: test-api-server.com http: paths: - path: / pathType: Prefix backend: service: name: test-api port: number: 443 EOF 查看連接憑證 # 查看連接憑證 echo | openssl s_client -servername test-api-server.com -connect 127.0.0.1:443 | grep CN # 查看憑證詳細資料 echo | openssl s_client -servername test-api-server.com -connect 127.0.0.1:443 | openssl x509 -inform pem -noout -text # 可以看到已經在使用 API server cert 訪問 API curl --resolve test-api-server.com:127.0.0.1 https://test-nginx-server.com/hello Hello World!\n部署 Ingress (TLS termination + TLS backend)# cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: tls-termination-tls-backend-ingress annotations: nginx.ingress.kubernetes.io/backend-protocol: \u0026#34;HTTPS\u0026#34; spec: ingressClassName: nginx tls: - hosts: - test-nginx-api-server.com secretName: nginx-server-cert rules: - host: test-nginx-api-server.com http: paths: - path: / pathType: Prefix backend: service: name: test-api port: number: 443 EOF 查看連接憑證 # 查看連接憑證 echo | openssl s_client -servername test-nginx-api-server.com -connect 127.0.0.1:443 | grep CN # 查看憑證詳細資料 echo | openssl s_client -servername test-nginx-api-server.com -connect 127.0.0.1:443 | openssl x509 -inform pem -noout -text # 可以看到在使用 Nginx server cert，但後台也會用 TLS 連接API 訪問 API curl --resolve test-nginx-api-server.com:127.0.0.1 https://test-nginx-server.com/hello Hello World!\n參考文件# https://cert-manager.io/docs/installation/ ","date":"April 25, 2022","img":"/hugo-theme-bootstrap-skeleton/blog/k8s_ingress_tls/thumbnail.jpeg","lang":"zh-hk","langName":"繁體中文","largeImg":"/hugo-theme-bootstrap-skeleton/blog/k8s_ingress_tls/thumbnail_hue56bd63f66b9ae2896db7005e752546c_31952_500x0_resize_q75_box.jpeg","permalink":"/hugo-theme-bootstrap-skeleton/blog/k8s_ingress_tls/","smallImg":"/hugo-theme-bootstrap-skeleton/blog/k8s_ingress_tls/thumbnail_hue56bd63f66b9ae2896db7005e752546c_31952_180x0_resize_q75_box.jpeg","tags":[{"title":"kubernetes","url":"/hugo-theme-bootstrap-skeleton/tags/kubernetes/"},{"title":"ingress-nginx","url":"/hugo-theme-bootstrap-skeleton/tags/ingress-nginx/"},{"title":"tls","url":"/hugo-theme-bootstrap-skeleton/tags/tls/"}],"timestamp":1650844800,"title":"K8S - TLS With Ingress Nginx"},{"content":"如何安裝 ingress-nginx\n安裝 ingress nginx# 前言# 此文章使用以下設定\nVersion Windows Windows 10 wsl2 linux Ubuntu-20.04 Docker Desktop 4.1.1(69879) Docker Kubernetes v1.21.5 要注意 ingress-nginx 由 K8S 開發. nginx-ingress 是由 nginx 開發，雖然都是用nginx作為 reverse proxy server 但設定上會有差別。\n安裝# 官網有提供各種安裝的選擇 Installation Guide - NGINX Ingress Controller (kubernetes.github.io)\n此文使用 Docker Desktop. 如果 k8s 是安裝在伺服器上，請選擇 Bare-metal.\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml 可以看到 k8s 會建立一堆資源\n用以下命令查看資源狀態，可以看到 EXTERNAL-IP 是 localhost。\nkubectl get all -n ingress-nginx Ingress controller 啟動後需要一定時間取得 EXTERNAL-IP ，如顯示 pending，請等待 1-2 分鐘。\n在 browser 輸入網址 http://localhost/ 可以看到以下畫面，代表安裝成功。\n如果 EXTERNAL-IP 一直顯示 pending，可以賞試在 Docker Desktop Troubleshoot 頁面 Reset Kubernetes cluster 然後重新啟動 Docker Desktop.\n再重新安裝 ingress-nginx.\nBare-metal ingress# 如果是使用 bare-metal，安裝在另外的伺服器上，需要自行填上自己伺服器的 IP。\nkubectl patch service ingress-nginx-controller -n ingress-nginx --patch \u0026#39;{\u0026#34;spec\u0026#34;: {\u0026#34;externalIPs\u0026#34;: [\u0026#34;172.28.240.1\u0026#34;] }}\u0026#39; 也可以安裝 MetalLB，自動分派 IP，此處不詳述。\n移除安裝# kubectl delete -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml ","date":"October 31, 2021","img":"/hugo-theme-bootstrap-skeleton/blog/k8s_ingress_installation/thumbnail.jpeg","lang":"zh-hk","langName":"繁體中文","largeImg":"/hugo-theme-bootstrap-skeleton/blog/k8s_ingress_installation/thumbnail_hue56bd63f66b9ae2896db7005e752546c_31952_500x0_resize_q75_box.jpeg","permalink":"/hugo-theme-bootstrap-skeleton/blog/k8s_ingress_installation/","smallImg":"/hugo-theme-bootstrap-skeleton/blog/k8s_ingress_installation/thumbnail_hue56bd63f66b9ae2896db7005e752546c_31952_180x0_resize_q75_box.jpeg","tags":[{"title":"kubernetes","url":"/hugo-theme-bootstrap-skeleton/tags/kubernetes/"},{"title":"ingress-nginx","url":"/hugo-theme-bootstrap-skeleton/tags/ingress-nginx/"}],"timestamp":1635638400,"title":"K8S - 安裝 Ingress Nginx"}]
