[{"content":"How to mount minio bucket as linux folder# install s3fs-fuse\n# install s3fs-fuse apt install s3fs s3fs --version mounting minio bucket\nMINIO_HOST=\u0026#34;http://192.168.64.131:9000\u0026#34; BUCKET_NAME=\u0026#34;my-bucket\u0026#34; ACCESS_KEY_ID=\u0026#34;dU2mOQuZqPbrTfIg\u0026#34; ACCESS_SECRET=\u0026#34;3T7qxg6ztoxVX3YqTHJAU6O46FqzZJ4k\u0026#34; MOUNT_FOLDER=\u0026#34;/mnt/minio-buckets/my-bucket\u0026#34; # \u0026#34;us-east-1\u0026#34; is minio default region ENDPOINT=\u0026#34;us-east-1\u0026#34; # perpare password file echo ${ACCESS_KEY_ID}:${ACCESS_SECRET} \u0026gt; ${HOME}/.passwd-s3fs chmod 600 ${HOME}/.passwd-s3fs # ensure folder exists and empty sudo mkdir -p ${MOUNT_FOLDER} ## try to mount, this will unmount when you press Ctrl+C sudo s3fs ${BUCKET_NAME} ${MOUNT_FOLDER} \\ -o dbglevel=info -f -o curldbg \\ -o passwd_file=${HOME}/.passwd-s3fs \\ -o host=${MINIO_HOST} \\ -o endpoint=${ENDPOINT} \\ -o use_path_request_style \\ -o allow_other # if mount successful, press Ctrl+C to exit # backup fstab file mkdir -p ${HOME}/backup sudo cp /etc/fstab ${HOME}/backup/fstab # append to fstab echo \u0026#34;${BUCKET_NAME} ${MOUNT_FOLDER} fuse.s3fs _netdev,passwd_file=${HOME}/.passwd-s3fs,host=${MINIO_HOST},endpoint=${ENDPOINT},use_path_request_style,allow_other 0 0\u0026#34; | sudo tee --append /etc/fstab # check fstab sudo cat /etc/fstab # apply updated fstab sudo mount -a # check mount status sudo df -h | grep s3fs # clearup command hsitory in this session history -c other useful command option\n-o ssl_verify_hostname=0 (for https, disable hostname checking) -o no_check_certificate (for https, disable ca checking, usful when cert is self signed) -o connect_timeout=5 -o logfile=/mnt/minio-buckets/s3fs.log -o passwd_file=/mnt/minio-buckets/.passwd-s3fs -o curldbg=normal unmount\n## remove config in /etc/fstab sudo vim /etc/fstab ## unmount folder sudo umount \u0026#34;/mnt/minio-buckets/my-bucket\u0026#34; Ref Docs# https://github.com/s3fs-fuse/s3fs-fuse https://aws.amazon.com/cn/blogs/china/s3fs-amazon-ec2-linux/ ","date":"February 22, 2023","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/blog/mount_minio_bucket/","smallImg":"","tags":[{"title":"minio","url":"/my_blog/tags/minio/"},{"title":"s3fs","url":"/my_blog/tags/s3fs/"},{"title":"s3","url":"/my_blog/tags/s3/"}],"timestamp":1677024000,"title":"How to Mount Minio Bucket as Linux Folder"},{"content":"When using gitlab ci, it always take a long time to build docker image because cache is not used.\nHere is how to setup executer using local cache to speedup build time.\nWhen do you need this?# If you have a standalone server that only used for gitlab runner, Shell Executor orUse Docker socket binding should be enough for you. You can skip this article.\nIf you can bear few minutes build time, just use kaniko or Use Docker-in-Docker.\nKeep watching if you don\u0026rsquo;t want to use socket binding or shell executor and want to reduce docker build time from few minutes to few seconds.\nSetup GitLag Runner# get registation token from gitlab admin panel, /admin/runners\nset var\nGITLAB_HOST=192.168.0.11 GITLAB_PORT=443 GITLAB_URL=\u0026#34;https://${GITLAB_HOST}:${GITLAB_PORT}/\u0026#34; REGISTRATION_TOKEN=\u0026#34;xxxxxxxxxxxxx\u0026#34; HARBOR_HOST=192.168.0.12 HARBOR_PORT=443 DEPLOY_FOLDER=/srv/gitlab-runner perpare file ane folder\nmkdir -p ${DEPLOY_FOLDER} mkdir -p ${DEPLOY_FOLDER}/config mkdir -p ${DEPLOY_FOLDER}/config/certs cd ${DEPLOY_FOLDER} # download gitlab server certificate openssl s_client -showcerts -connect ${GITLAB_HOST}:${GITLAB_PORT} \u0026lt; /dev/null 2\u0026gt;/dev/null | sudo openssl x509 -outform PEM \u0026gt; ${DEPLOY_FOLDER}/config/certs/${GITLAB_HOST}.crt # download harbor server certificate openssl s_client -showcerts -connect ${HARBOR_HOST}:${HARBOR_PORT} \u0026lt; /dev/null 2\u0026gt;/dev/null | sudo openssl x509 -outform PEM \u0026gt; ${DEPLOY_FOLDER}/${HARBOR_HOST}.crt register gitlab runner and generate config file\nsudo docker run --rm -v ${DEPLOY_FOLDER}/config:/etc/gitlab-runner/ docker.io/gitlab/gitlab-runner:v15.8.2 register \\ --non-interactive \\ --tag-list=\u0026#34;dind-runner\u0026#34; \\ --name=\u0026#34;dind-runner\u0026#34; \\ --executor \u0026#34;docker\u0026#34; \\ --docker-image \u0026#34;docker:23\u0026#34; \\ --docker-tlsverify=\u0026#34;false\u0026#34; \\ --run-untagged=\u0026#34;true\u0026#34; \\ --custom_build_dir-enabled \\ --builds-dir=\u0026#34;/builds\u0026#34; \\ --docker-volumes=\u0026#34;/builds:/builds\u0026#34; \\ --env=\u0026#39;GIT_CLONE_PATH=$CI_BUILDS_DIR/$CI_CONCURRENT_ID/$CI_PROJECT_NAME\u0026#39; \\ --cache-dir=\u0026#34;/cache\u0026#34; \\ --docker-volumes=\u0026#34;/cache:/cache\u0026#34; \\ --docker-volumes=\u0026#34;/var/run/docker.sock:/var/run/docker.sock\u0026#34; \\ --docker-volumes=\u0026#34;/etc/docker/certs.d:/etc/docker/certs.d\u0026#34; \\ --url=\u0026#34;${GITLAB_URL}\u0026#34; \\ --registration-token=\u0026#34;${REGISTRATION_TOKEN}\u0026#34; update concurrent to 10\nsudo sed -i \u0026#39;s/concurrent.*/concurrent = 10/\u0026#39; ${DEPLOY_FOLDER}/config/config.toml create docker-compose file\necho \u0026#34; services: dind: container_name: dind image: docker:23-dind restart: always privileged: true environment: # force docker deamon to disable TLS DOCKER_TLS_CERTDIR: \u0026#39;\u0026#39; command: - --storage-driver=overlay2 networks: - gitlab-runner volumes: - ${DEPLOY_FOLDER}/${HARBOR_HOST}.crt:/etc/docker/certs.d/${HARBOR_HOST}/ca.crt runner: container_name: runner restart: always image: docker.io/gitlab/gitlab-runner:v15.8.2 depends_on: - dind environment: - DOCKER_HOST=tcp://dind:2375 volumes: - ${DEPLOY_FOLDER}/config:/etc/gitlab-runner networks: - gitlab-runner networks: gitlab-runner: {} \u0026#34; \u0026gt; ${DEPLOY_FOLDER}/docker-compose.yml start container cd ${DEPLOY_FOLDER} \u0026amp;\u0026amp; docker compose up -d --wait\nview logs docker compose logs -n 100 -f\nyou can download single script file here\ncreate gitlab-ci file# create .gitlab-ci.yml file in your git project and commit, it will trigger pipline\nbuild-docker-image: stage: deploy tags: - docker-dind-runner variables: CI_REGISTRY: 192.168.0.12:443 CI_REGISTRY_USER: admin CI_REGISTRY_PASSWORD: xxxxxxxx script: - docker login -u \u0026#34;$CI_REGISTRY_USER\u0026#34; -p \u0026#34;$CI_REGISTRY_PASSWORD\u0026#34; $CI_REGISTRY - docker build . -t \u0026#34;${CI_REGISTRY}/apps/${CI_PROJECT_PATH_SLUG}:latest\u0026#34; --build-arg BUILDKIT_INLINE_CACHE=1 - docker push \u0026#34;${CI_REGISTRY}/apps/${CI_PROJECT_PATH_SLUG}:latest\u0026#34; I am using a new dotnet webapi as demo, the first build takes 01:18 but second build only take 18s with code update. As long as you don\u0026rsquo;t update .csproj file, you can use docker build layer local cache.\nyou can watch job container created inside dind container when trigger job\ndocker exec -t dind watch -n 1 docker ps also setup crontab to clearup every month prevent disk full\n(crontab -l \u0026amp;\u0026amp; echo \u0026#34;0 0 1 * * docker exec dind docker system prune --all --force --filter \u0026#39;until=168h\u0026#39;\u0026#34;) | crontab - (crontab -l \u0026amp;\u0026amp; echo \u0026#34;0 0 1 * * docker exec dind docker system prune --all --force --volumes\u0026#34;) | crontab - crontab -l ","date":"February 14, 2023","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/blog/setup_gitlab_runner/","smallImg":"","tags":[{"title":"gitlab","url":"/my_blog/tags/gitlab/"},{"title":"gitlab-runner","url":"/my_blog/tags/gitlab-runner/"},{"title":"gitlab-ci","url":"/my_blog/tags/gitlab-ci/"},{"title":"devops","url":"/my_blog/tags/devops/"},{"title":"ci-cd","url":"/my_blog/tags/ci-cd/"}],"timestamp":1676332800,"title":"Setup Gitlab Runner With Cacheable Docker Executor"},{"content":"When first time seeing all this docker tag, i am very confused about what is these tag and which should i pick.\nHere i write down some tag that i know.\nMost of these tag represent different versions of linux such as debian, ubuntu, alpine.\nAlpine# Alpine is a extremely small size of linux that is only about 7 MB. You can see their about page here.\nDebian and Ubuntu# Debian and Ubuntu use diff code name for diff os versions, you can see full code name here : Debian, Ubuntu\nDebian code name# os version code name 11 bullseye 10 buster 9 stretch 8 jessie slim (slimmer)# slim is a smaller size of Debian Linux, it removed some packages normally not necessary within containers.\nIt must come with one of debian release code like :bullseye-slim\nYou can see description in dockerhub https://hub.docker.com/_/debian\nSize different here:\nREPOSITORY TAG IMAGE ID SIZE debian bullseye-slim 9f61210833de 80.5MB debian bullseye 5c8936e57a38 124MB Ubuntu code name# os version code name Ubuntu 22.04 LTS jammy Ubuntu 20.04 LTS focal Ubuntu 18.04 LTS bionic Ubuntu 16.04 LTS xenial Ubuntu 14.04 LTS trusty rc (Release Candidates)# rc is a pre-release version that is not stable yet but close to release.\nltsc (Long Term Servicing Channel)# ltsc means stable version of windows server, you can see it on dotnet image\n","date":"January 26, 2023","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/blog/what_is_these_docker_tags_mean/","smallImg":"","tags":[{"title":"docker","url":"/my_blog/tags/docker/"},{"title":"docker-tag","url":"/my_blog/tags/docker-tag/"}],"timestamp":1674691200,"title":"What Is These Docker Tags Mean (Bullseye, Slim, Alpine, Jammy)?"},{"content":"I will show you how i create my resume page and deploy to cloudflare pages. Here is my live resume https://resume.isaacyip.com/.\nCreate a repo with your resume html page on github. You can fork my repo here Buy a domain name in cloudflare. Once you bought a domain, login cloudflare, goto Pages \u0026gt; Create project \u0026gt; Connect to Git Add your github account and select your resume repository. since cloudflare only take index.html as default page, we will rename our resume html file to index.html in build command. When the build success you can see your website on the url. Then click Continue to project. Setup your domain name for the page. Wait a few minutes, until the domain turn to Active, then you can access your resume page with your domain ","date":"December 13, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/blog/resume_on_cloudflare_page/","smallImg":"","tags":[{"title":"cloudflare-pages","url":"/my_blog/tags/cloudflare-pages/"},{"title":"cloudflare","url":"/my_blog/tags/cloudflare/"},{"title":"resume","url":"/my_blog/tags/resume/"}],"timestamp":1670889600,"title":"Deploy My Resume Html Page to Cloudflare"},{"content":"考了 k8S CKA 證書，總結一下經過和要點。\n考了 K8S CKA 的考試，考試是 2022 年 7 月特價的時候買的，花了 275 美元，原價是 375 美元。拖了半年才考，還挺簡單的。 真實考試比 killer 的模擬考試簡單很多，太概 70 分鐘就做完了，killer 的模擬考試就算熟練也差不多要 110 分鐘。能過 killer 的模擬考試基本都不用擔心。\n補充，第二天就收到合格的電郵，證書放在 AWS 的 S3 storage 上，可以隨時看 https://ti-user-certificates.s3.amazonaws.com/e0df7fbf-a057-42af-8a1f-590912be5460/2619881f-c1df-4f11-a4aa-c695e7ca18da-yip-wai-lung-9f8a1f2c-bffd-4e9a-a49d-e9ed7e296835-certificate.pdf\n考試流程# 網上報名，報名之後一年內可以考，可以重考一次。 到killer.sh練習。 到trainingportal預約考試時間。\n這裡還有 Handbook 跟 Important Instructions，最好看一下。 準備好房間(沒有其他人)，攝像頭(要可移動的)，麥克風(不能用頭載式耳機)，身份證明(我是用護照的)。 預先關掉所有其他程式，我是用新建立的 windows 用戶的，比較乾淨。 考試時間的 30 分鐘前要到trainingportal下載跟安裝 PSI 瀏覽器，花了大約 20 分鐘。開啟瀏覽器的時候會告訴你還有什麼程式需要關閉。瀏覽器要我關掉 hyper-v 的服務，花了 5 分鐘才關掉。 開啟瀏覽器後會有人檢查你的身份證明，房間。對話都是打字的，不用講話。 檢查房間要拿起攝像頭，按照指示拍攝周圍，桌面桌底不能有雜品，電腦跟電線都可以，飲品只能是水，茶都不行。\n這個檢查比較久，檢查了大約 20 分鐘，但不用擔心，檢查不算考試時間的。 然後開始考試。 考試環境# 2022 年中更換考試環境，不再只有 terminal 了，轉成 VM，可以用 firefox 查官網文檔，可以用 ubuntu 的 mousepad，類似 nodepad 的東西。\n在 mousepad 改完 yaml 檔案再複製進 vim，不用精通 vim 了，只要會複製貼上就可以，複製貼上記得用Ctrl+Shift+c 和 Ctrl+Shift+v。\n但是因為是遠程控制 VM，移動 firefox 的時候非常慢，盡量不要動它，mousepad 跟 terminal 倒是很順暢，設定都不用改。PSI 瀏覽器會佔了上面一部份畫面，畫面會比較小。\n因為不能紀錄真畫面，這是在 killercoda 模擬出來的，有需要可以自己試試。\nhttps://killercoda.com/kimwuestkamp/scenario/cks-cka-ckad-remote-desktop 題目# 只有 17 題，都不難，下面是我記得的。\ncreate node port service create ingress create pod with shared volume fix a worker node create network policy upgrade kubeadm, kubectl, kubelet in master node to newer version backup and restore etcd count ready worker node and type into a text file create deamonset that deploy on every node include master node create cluster role and bind to a service account create pvc and mount into a pod, then change volume size output log from a pod to a text file scale deployment to 3 參考連結# Certified Kubernetes Administrator (CKA) 這裡付錢 Training Portal 這裡預約考試 killer.sh 買了考試可以在這裡練習，每次可以用 36 小時，可以用 2 次。 killercoda 這是免費版 killer，題目比較少。 handbook Important Instructions: CKA and CKAD Frequently Asked Questions: CKA and CKAD \u0026amp; CKS ","date":"December 10, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/blog/k8s_cka_exam/","smallImg":"","tags":[{"title":"kubernetes","url":"/my_blog/tags/kubernetes/"},{"title":"exam","url":"/my_blog/tags/exam/"},{"title":"cka","url":"/my_blog/tags/cka/"}],"timestamp":1670630400,"title":"K8S CKA 考試總結"},{"content":"Hello, I am a software engineer working on backend development and devops.\nHere is my GitHub.\nHere is my online Resume.\n","date":"November 15, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/about/","smallImg":"","tags":[],"timestamp":1668470400,"title":"About"},{"content":"My linux cheat Sheet base on Ubuntu\nawk# # skip first line, useful for skip colume name awk \u0026#39;NR!=1 {print}\u0026#39; # filter when colume one not match regex pattern awk \u0026#39;$1 !~ /^some-regex-pattern$/ {print}\u0026#39;) # print colume 1, 2 and added \u0026#34;|\u0026#34; in between awk \u0026#39;{print $1\u0026#34;|\u0026#34;$2}\u0026#39;) # print with right padding space awk \u0026#39;{printf \u0026#34;%-20s %-20s\\n\u0026#34;,$1,$2}\u0026#39; basic# # create multi line file cat \u0026lt;\u0026lt;EOT \u0026gt; multi_line_file.txt line1 line2 EOT # scp upload folder scp -r \u0026#34;~/some_folder\u0026#34; user@remote_host:~/ # upload key for login scp \u0026#34;~/.ssh/id_rsa.pub\u0026#34; user@remote_host:~/.ssh/authorized_keys # ssh tunnel ssh user@remote_host -L \u0026lt;local_port\u0026gt;:\u0026lt;target_host\u0026gt;:\u0026lt;target_port\u0026gt; # check memory usage htop free -h sync time with hk ntp server# # create config file mkdir -p /etc/systemd/timesyncd.conf.d/ cat \u0026lt;\u0026lt;EOT \u0026gt; /etc/systemd/timesyncd.conf.d/hk_ntp.conf [Time] NTP=stdtime.gov.hk EOT # set timezone timedatectl set-timezone \u0026#39;Asia/Hong_Kong\u0026#39; # restart timesyncd service systemctl restart systemd-timesyncd # check status timedatectl timesync-status timedatectl show-timesync IPv6 users may also access NTP service through time.hko.hk\nref: https://man7.org/linux/man-pages/man5/timesyncd.conf.d.5.html ref: https://www.hko.gov.hk/en/nts/ntime.htm add apt repo# # add repo echo \u0026#34;deb http://tw.archive.ubuntu.com/ubuntu/ jammy main\u0026#34; \u0026gt; /etc/apt/sources.list.d/apt_tw_mirror.list apt update deb [ option1=value1 option2=value2 ] uri suite [component1] [component2] [...]\ndeb: deb or deb-src, deb-src means include source code, only used when you want to modify source code uri: repo uri, launchpad provides some repo here suite: usually use ubuntu version code name here component: usually have four option main - Officially supported software restricted - Supported software that is not available under a completely free license. universe - Community maintained software, i.e. not officially supported software. multiverse - Software that is not free ref: https://manpages.ubuntu.com/manpages/xenial/man5/sources.list.5.html ref: https://help.ubuntu.com/community/Repositories/Ubuntu disk related# # check total dir size du -sh /var/* # check disk size df -h # expand vm linux disk sudo apt install parted sudo parted -l (parted) resizepart 1 100% (parted) quit sudo resize2fs /dev/sda disable swap and kswapd0# # turnoff swap swapoff -a # 0 swappiness really prevents from any swapping even if there is a swap storage available echo \u0026#39;vm.swappiness=0\u0026#39; \u0026gt; /etc/sysctl.d/swappiness_zero.conf # reload all sysctl config sysctl --system # search swap unit systemctl list-units *swap* --all # mask and stop swap unit permanently systemctl mask swap.target systemctl stop swap.target # verify free -m sysctl vm.swappiness systemctl status *swap* --all ref: kernel swappiness\nfind# Linux manual page - find\n# search log file find /var/log -iname \u0026#39;*.log\u0026#39; -type f # search dir find $HOME -iname \u0026#39;php\u0026#39; -type d # search file bigger than 10MiB find $HOME -type f -size +10M # search file created more than 7 days find $HOME -type f -ctime +7 # search file modified within 60 mins find $HOME -type f -mmin -60 # move find $HOME -type f -name \u0026#34;test.txt\u0026#34; -exec move {} ./new_dir/ \\; archive log files# # zip log file find /var/log -regextype posix-egrep -regex \u0026#39;.*/.*([0-9]{8})$\u0026#39; -exec gzip {} \\; # move ziped log files to other folder with same dir structure LOG_ARCHIVED_FOLDER=/mnt/data/log_archived/ cd /var/log find . -type d -exec mkdir -p \u0026#34;$LOG_ARCHIVED_FOLDER/{}\u0026#34; \\; find . -type f -name \u0026#39;*.gz\u0026#39; -exec mv --backup \u0026#34;{}\u0026#34; \u0026#34;$LOG_ARCHIVED_FOLDER/{}\u0026#34; \\; skip sudo password# echo \u0026#34;$USER ALL=(ALL) NOPASSWD: ALL\u0026#34; | sudo tee /etc/sudoers.d/$USER reference# The Linux Kernel Linux manual page Ubuntu Docs ","date":"October 10, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/docs/my-cheat-sheet/linux_cheat_sheet/","smallImg":"","tags":[{"title":"linux","url":"/my_blog/tags/linux/"},{"title":"cheat-sheet","url":"/my_blog/tags/cheat-sheet/"}],"timestamp":1665360000,"title":"Linux Cheat Sheet"},{"content":"My other cheat Sheet\nKubernetes# official cheat sheet kubectl go template url # kubectl exec one of deployment pod kubectl exec -it deploy/my-app -n bes -- bash # kubectl get all resource includeing custom resource kubectl get $(kubectl api-resources --namespaced=true --no-headers -o name | grep -v -E \u0026#39;events|bindings$|localsubjectaccessreviews\u0026#39; | paste -s -d, - ) # kubectl show pod cpu and memory config of first container kubectl get pod -o custom-columns=POD_NAME:.metadata.name,CONTAINER:.spec.containers[0].name,CPU_MIN:.spec.containers[0].resources.limits.cpu,CPU_MAX:.spec.containers[0].resources.requests.cpu,MEM_MAX:.spec.containers[0].resources.limits.memory,MEM_MIN:.spec.containers[0].resources.requests.memory,STATUS:.status.phase # kubectl list all nodeport kubectl get svc --all-namespaces -o go-template=\u0026#39;{{range .items}}{{ $svc := . }}{{range.spec.ports}}{{if .nodePort}}{{.nodePort}}{{\u0026#34;,\u0026#34;}}{{if .name}}{{printf \u0026#34;%-10s\u0026#34; .name}}{{else}}{{printf \u0026#34;%-10s\u0026#34; \u0026#34;\u0026#34;}}{{end}}{{\u0026#34;,\u0026#34;}}{{$svc.metadata.namespace}}{{\u0026#34;,\u0026#34;}}{{$svc.metadata.name}}{{\u0026#34;\\n\u0026#34;}}{{end}}{{end}}{{end}}\u0026#39; # create nodeport svc cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: v1 kind: Service metadata: name: my-svc namespace: default spec: ports: - port: 80 nodePort: 30002 selector: app: my-app type: NodePort EOF # backup etcd data sudo ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \\ --cacert=/etc/kubernetes/pki/etcd/ca.crt \\ --cert=/etc/kubernetes/pki/apiserver-etcd-client.crt \\ --key=/etc/kubernetes/pki/apiserver-etcd-client.key \\ snapshot save ~/etcd_backup # view container log sudo docker logs -n 100 -f $(sudo docker ps -f name=k8s_kube-vip -q) sudo docker logs -n 100 -f $(sudo docker ps -f name=k8s_etcd -q) sudo docker logs -n 100 -f $(sudo docker ps -f name=k8s_kube-apiserver -q) sudo docker logs -n 100 -f $(sudo docker ps -f name=k8s_kube-scheduler -q) sudo docker logs -n 100 -f $(sudo docker ps -f name=k8s_kube-controller-manager -q) # create kubeconfig file NAMESPACE=default USER_NAME=my-user USER_TOKEN_NAME=$(kubectl get serviceaccount ${USER_NAME} -n ${NAMESPACE} -o=jsonpath=\u0026#39;{.secrets[0].name}\u0026#39;) USER_TOKEN_VALUE=$(kubectl get secret/${USER_TOKEN_NAME} -n ${NAMESPACE} -o=go-template=\u0026#39;{{.data.token}}\u0026#39; | base64 --decode) CURRENT_CONTEXT=$(kubectl config current-context) CURRENT_CLUSTER=$(kubectl config view --raw -o=go-template=\u0026#39;{{range .contexts}}{{if eq .name \u0026#34;\u0026#39;\u0026#39;\u0026#39;${CURRENT_CONTEXT}\u0026#39;\u0026#39;\u0026#39;\u0026#34;}}{{ index .context \u0026#34;cluster\u0026#34; }}{{end}}{{end}}\u0026#39;) CLUSTER_CA=$(kubectl config view --raw -o=go-template=\u0026#39;{{range .clusters}}{{if eq .name \u0026#34;\u0026#39;\u0026#39;\u0026#39;${CURRENT_CLUSTER}\u0026#39;\u0026#39;\u0026#39;\u0026#34;}}\u0026#34;{{with index .cluster \u0026#34;certificate-authority-data\u0026#34; }}{{.}}{{end}}\u0026#34;{{ end }}{{ end }}\u0026#39;) CLUSTER_SERVER=$(kubectl config view --raw -o=go-template=\u0026#39;{{range .clusters}}{{if eq .name \u0026#34;\u0026#39;\u0026#39;\u0026#39;${CURRENT_CLUSTER}\u0026#39;\u0026#39;\u0026#39;\u0026#34;}}{{ .cluster.server }}{{end}}{{ end }}\u0026#39;) sudo tee ${USER_NAME}.kubeconfig \u0026lt;\u0026lt;EOF apiVersion: v1 kind: Config current-context: ${CURRENT_CONTEXT} contexts: - name: ${CURRENT_CONTEXT} context: cluster: ${CURRENT_CONTEXT} user: ${USER_NAME} namespace: ${NAMESPACE} clusters: - name: ${CURRENT_CONTEXT} cluster: certificate-authority-data: ${CLUSTER_CA} server: ${CLUSTER_SERVER} users: - name: ${USER_NAME} user: token: ${USER_TOKEN_VALUE} EOF kubectl get pods -n ${NAMESPACE} --kubeconfig=${USER_NAME}.kubeconfig Helm# # download helm chart helm pull bitnami/redis --untar --untardir ./redis-helm-charts # render helm template helm template my-redis bitnami/redis --output-dir=./otuput-dir --dry-run -f=\u0026#34;my-values.yaml\u0026#34; # ls installed app helm ls -A # get installed values helm get values my-redis -n redis ArgoCD# Ref: https://argo-cd.readthedocs.io/en/stable/user-guide/commands/argocd/\n# get init admin password kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\u0026#34;{.data.password}\u0026#34; | base64 -d; echo # create container docker run --rm -it argoproj/argocd # login argocd login \u0026#34;192.168.0.1\u0026#34; --insecure --username \u0026#34;isaac\u0026#34; --password \u0026#34;xxxxxx\u0026#34; # restart deployment argocd app actions run \u0026#34;my-app\u0026#34; restart --kind Deployment # update password argocd account update-password --account admin # set app param kubectl patch Application --type=merge -n=argocd -p \u0026#39;{\u0026#34;spec\u0026#34;:{\u0026#34;source\u0026#34;:{\u0026#34;helm\u0026#34;:{\u0026#34;parameters\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;replicaCount\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;0\u0026#34;}]}}}}\u0026#39; my-app # set app param2 kubectl exec deploy/argocd-server -n argocd -- bash -c \u0026#34;argocd login 127.0.0.1:8080 --insecure --username admin --password \u0026#39;XXXXXX\u0026#39;\u0026#34; kubectl exec deploy/argocd-server -n argocd -- bash -c \u0026#34;argocd app set my-app -p replicaCount=0\u0026#34; Docker# # remove image docker image rm my-reg/my-image:latest # remove image with filter docker image rm $(docker images --filter=reference=\u0026#39;my-reg/*\u0026#39; --format \u0026#34;{{.Repository}}:{{.Tag}}\u0026#34;) # add new tag docker tag \u0026#34;my-reg/my-image:latest\u0026#34; \u0026#34;my-reg/my-image:new-tag\u0026#34; # docker save image as file docker save -o \u0026#34;my-image.tar\u0026#34; \u0026#34;my-reg/my-image:latest\u0026#34; # docker load image file docker load --input \u0026#34;my-image.tar\u0026#34; # rm all image that is not latest tag docker image rm $(docker images | awk \u0026#39;NR!=1 \u0026amp;\u0026amp; $2 !~ /\u0026lt;none\u0026gt;/ \u0026amp;\u0026amp; $2 !~ /^latest$)/ {print $1\u0026#34;:\u0026#34;$2}\u0026#39;) mongodb# # backup database to file mongodump --uri=\u0026#34;mongodb://admin:XXXXXW@192.168.0.101:10001,192.168.0.102:10002,192.168.0.103:10003/?authSource=admin\u0026amp;replicaSet=my_replica_set\u0026amp;readPreference=primary\u0026#34; --out=mongodump/ --db=my_db # restore database from file mongorestore --uri=\u0026#34;mongodb://admin:XXXXXW@192.168.0.101:10001,192.168.0.102:10002,192.168.0.103:10003/?authSource=admin\u0026amp;replicaSet=my_replica_set\u0026amp;readPreference=primary\u0026#34; --db=my_db mongodump/my_db minio-client# # create config file mkdir -p $HOME/.mc/ tee $HOME/.mc/config.json \u0026lt;\u0026lt;EOF { \u0026#34;version\u0026#34;: \u0026#34;10\u0026#34;, \u0026#34;aliases\u0026#34;: { \u0026#34;myminio\u0026#34;: { \u0026#34;url\u0026#34;: \u0026#34;http://192.168.0.100:9000\u0026#34;, \u0026#34;accessKey\u0026#34;: \u0026#34;xxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;secretKey\u0026#34;: \u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;, \u0026#34;api\u0026#34;: \u0026#34;s3v4\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;auto\u0026#34; } } } EOF # upload files in /minio-tmp/* to minio server docker run --rm -it --entrypoint=\u0026#39;\u0026#39; \\ -v /minio-tmp/:/minio-tmp/ \\ -v $HOME/.mc/config.json:$HOME/.mc/config.json \\ minio/mc \\ sh -c \u0026#39;mc cp /minio-tmp/* myminio/my-bucket\u0026#39; # delete files older than 7 days in minio server docker run --rm -it --entrypoint=\u0026#39;\u0026#39; \\ -v $HOME/.mc/config.json:$HOME/.mc/config.json \\ minio/mc \\ sh -c \u0026#39;mc find myminio/my-bucket --older-than 7d --exec \u0026#39;mc rm {}\u0026#39;\u0026#39; ","date":"October 10, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/docs/my-cheat-sheet/my_cheat_sheet/","smallImg":"","tags":[{"title":"cheat-sheet","url":"/my_blog/tags/cheat-sheet/"}],"timestamp":1665360000,"title":"Other Cheat Sheet"},{"content":"My tools List\nOnline tools# appdevtools regex101 converter encode/decode api tester tls cert decoder .net appsettings to k8s env json web token hk id generator online diagram tools - niolesk k8s generator (Octopus) chrome / edge extensions# Adblock Google Translate grammarly uBlacklist Wappalyzer Common Tools# chrome firefox edge 7zip filezilla PicPick Slack drawio notepad++ Notepad2 Zoom Development Tool# windows features – Windows Subsystem for Linux windows features - Container Hyper-V wsl2 Docker Desktop Lens (K8S UI tools) PuTTY SuperPuTTY git Visual Studio Code Visual Studio 2022 python nodejs Postman SoapUI NSwagStudio winScp DB tools# SQL Server Management Tools HeidiSQL MySQL Workbench MongoDB Shell MongoDB Compass other tools# AutoHotkey Fiddler S3 Browser Remote Desktop Connection Manager Log Parser SikuliX (automate anything with ui) ","date":"October 10, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/docs/my_tools_list/","smallImg":"","tags":[{"title":"cheat-sheet","url":"/my_blog/tags/cheat-sheet/"}],"timestamp":1665360000,"title":"Tools List"},{"content":"如何使用私錀登入 Linux\nSSH - 使用私錀登入# 生成一對公鑰和私鑰 # works on linux and windows ssh-keygen ls ~/.ssh 預設生成在 ~/.ssh，id_rsa 是私鑰，id_rsa.pub 是公鑰\nid_rsa id_rsa.pub\n上傳公鑰到伺服器 # only for linux ssh-copy-id username@remote_host 如果使用 windows，打開 cmd，使用 scp 上傳金鑰\n# only for cmd scp %USERPROFILE%/.ssh/id_rsa.pub isaac@192.168.0.100:~/tmpe_id_rsa.pub ssh isaac@192.168.0.100 \u0026#34;mkdir -p ~/.ssh \u0026amp;\u0026amp; cat ~/tmpe_id_rsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys \u0026amp;\u0026amp; rm ~/tmpe_id_rsa.pub\u0026#34; 以上命令會把公鑰上傳到伺服器的檔案 ~/.ssh/authorized_keys。\n3.現在登入不用密碼了\nssh isaac@192.168.0.100 ","date":"October 3, 2022","img":"","lang":"zh-hk","langName":"繁體中文","largeImg":"","permalink":"/my_blog/blog/ssh_login_by_key/","smallImg":"","tags":[{"title":"ssh","url":"/my_blog/tags/ssh/"},{"title":"linux","url":"/my_blog/tags/linux/"}],"timestamp":1664755200,"title":"SSH - 使用私錀登入"},{"content":"如何使用 openssl 生成 TLS 需要的憑證\n使用 openssl 生成 TLS 憑證# 生成自簽伺服器證書# openssl req -x509 -nodes -newkey rsa:2048 \\ -subj=\u0026#39;/CN=Self Sign Cert\u0026#39; \\ -extensions usr_cert \\ -addext \u0026#34;keyUsage = nonRepudiation, digitalSignature, keyEncipherment\u0026#34; \\ -addext \u0026#34;extendedKeyUsage = serverAuth\u0026#34; \\ -addext \u0026#34;subjectAltName = DNS:www.server.com,DNS:localhost,IP:127.0.0.1\u0026#34; \\ -out=crt.pem -keyout=key.pem 生成完整憑證鏈# 生成自簽根憑證 Generate self sign root CA cert# # 生成私鑰 # generate private key openssl genrsa -out=root_ca_key.pem 2048 # 用私鑰生成根憑證 # generate root cert from private key openssl req -x509 -sha256 -new -days=10950 \\ -subj=\u0026#39;/CN=Root CA/C=HK/L=Hong Kong\u0026#39; \\ -addext \u0026#34;keyUsage = critical, keyCertSign, cRLSign\u0026#34; \\ -key=root_ca_key.pem -out=root_ca_crt.pem # 生成流水號，每次簽發證書，流水號會加一 # create root ca serial number file, this will record how many cert this ca issued openssl rand -hex -out=root_ca_srl.txt 20 # 檢查憑證訊息 # check cert info openssl x509 -in root_ca_crt.pem -text 生成中間憑證 Issue intermediate CA cert# # 憑證配置 # cert config tee inter_ca_ext.cnf \u0026lt;\u0026lt;EOF [inter_ca_ext] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid:always,issuer basicConstraints = critical, CA:TRUE, pathlen:0 keyUsage = critical, keyCertSign, cRLSign EOF # 生成私鑰 # generate private key openssl genrsa -out=inter_ca_key.pem 2048 # 生成 CSR # generate CSR (Certificate Signing Request) openssl req -sha256 -new -subj=\u0026#39;/CN=Intermediate CA/C=HK/L=Hong Kong\u0026#39; \\ -key=inter_ca_key.pem -out=inter_ca_csr.pem # 簽發中間憑證 # issue intermediate ca with root ca openssl x509 -req -days=1095 -CAserial=root_ca_srl.txt \\ -CA=root_ca_crt.pem -CAkey=root_ca_key.pem \\ -extfile=inter_ca_ext.cnf -extensions=inter_ca_ext \\ -in=inter_ca_csr.pem -out=inter_ca_crt.pem # 生成流水號，每次簽發證書，流水號會加一 # create root ca serial number file, this will record how many cert this ca issued openssl rand -hex -out=inter_ca_srl.txt 20 # 檢查憑證訊息 # check cert info openssl x509 -in inter_ca_crt.pem -text 生成伺服器憑證 Generate Server Cert# # 憑證配置 # cert config tee server_ext.cnf \u0026lt;\u0026lt;EOF [server_ext] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer basicConstraints = critical, CA:FALSE keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = critical, serverAuth subjectAltName = @server_ext_san [server_ext_san] DNS.1 = nginx.test.isaac.com DNS.2 = localhost IP.1 = 127.0.0.1 EOF # 生成私鑰 # generate private key openssl genrsa -out=server_key.pem 2048 # 生成 CSR openssl req -sha256 -new -subj \u0026#34;/CN=Server Cert/C=HK/L=Hong Kong\u0026#34; \\ -key=server_key.pem -out=server_csr.pem # 簽發伺服器憑證 # issue server cert with intermediate ca openssl x509 -req -days=365 -CAserial=inter_ca_srl.txt \\ -CA=inter_ca_crt.pem \\-CAkey=inter_ca_key.pem \\ -extfile=server_ext.cnf -extensions=server_ext \\ -in=server_csr.pem -out=server_crt.pem # 檢查憑證訊息 # check cert info openssl x509 -in server_crt.pem -text 生成客戶端憑證 Generate Client Cert# # 憑證配置 # cert config tee client_ext.cnf \u0026lt;\u0026lt;EOF [client_ext] subjectKeyIdentifier = hash authorityKeyIdentifier = keyid,issuer basicConstraints = critical, CA:FALSE keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = critical, clientAuth EOF # 生成私鑰 # generate private key openssl genrsa -out=client_key.pem 2048 # 生成 CSR openssl req -sha256 -new -subj \u0026#34;/CN=Client Cert/C=HK/L=Hong Kong\u0026#34; \\ -key=client_key.pem -out=client_csr.pem # 簽發客戶端憑證 # issue client cert with intermediate ca openssl x509 -req -days=365 -CAserial=inter_ca_srl.txt \\ -CA=inter_ca_crt.pem \\-CAkey=inter_ca_key.pem \\ -extfile=client_ext.cnf -extensions=client_ext \\ -in=client_csr.pem -out=client_crt.pem # 檢查憑證訊息 # check cert info openssl x509 -in client_crt.pem -text 其他實用命令# 下載伺服器憑證# echo -n | openssl s_client -connect www.google.com:443 | openssl x509 \u0026gt; google_crt.pem 下載憑證鏈# openssl s_client -showcerts -verify 5 -connect www.google.com:443 \u0026lt; /dev/null | awk \u0026#39;/BEGIN CERTIFICATE/,/END CERTIFICATE/{ if(/BEGIN CERTIFICATE/){a++}; out=\u0026#34;cert_chain.pem\u0026#34;; print \u0026gt;out}\u0026#39; 增加信任憑證# ubuntu\nsudo apt-get install -y ca-certificates sudo cp ca.crt /usr/local/share/ca-certificates sudo update-ca-certificates powershell\nImport-Certificate -FilePath \u0026#34;C:\\crt.pem\u0026#34; -CertStoreLocation cert:\\CurrentUser\\Root Import-Certificate -FilePath \u0026#34;C:\\crt.pem\u0026#34; -CertStoreLocation Cert:\\LocalMachine\\Root docker ubuntu container\ndocker run --rm -it \\ -v=/my_certs/root_crt.pem:/etc/ssl/certs/root_crt.pem \\ wbitt/network-multitool bash 加密/解密私鑰# # 生成 RSA 私鑰 openssl genrsa -out=rsa_key.pem 2048 # 將私鑰轉換 pkcs8 格式 openssl pkcs8 -topk8 -in rsa_key.pem -out key.pem -nocrypt # 加密私鑰 openssl pkcs8 -topk8 -in key.pem -out key_encrypt.pem # 解密私鑰 openssl pkcs8 -topk8 -in key_encrypt.pem -out key_decrypt.pem 格式轉換# ## 生成自簽證書 openssl req -x509 -nodes -newkey rsa:2048 -subj=\u0026#39;/CN=Self Sign Cert\u0026#39; -out=crt.pem -keyout=key.pem ## PEM 轉 PFX openssl pkcs12 -in=crt.pem -inkey=key.pem -export -out=crt.pfx ## PFX 轉 PEM openssl pkcs12 -in=crt.pfx -out=crt_key.pem -nodes ## PEM 轉 DER openssl x509 -outform der -in crt.pem -out crt.der ## DER 轉 PEM openssl x509 -inform der -in crt.der -out crt_from_der.pem ## PKCS#8 轉 PKCS#1 openssl rsa -in key.pem -out key_pkcs1.pem 參考資料# https://www.openssl.org/docs/man1.1.1/man1/ https://www.openssl.org/docs/man1.1.1/man5/x509v3_config.html https://datatracker.ietf.org/doc/html/rfc5280 https://en.wikipedia.org/wiki/PKCS ","date":"May 1, 2022","img":"/my_blog/blog/openssl_create_cert/thumbnail.png","lang":"zh-hk","langName":"繁體中文","largeImg":"/my_blog/blog/openssl_create_cert/thumbnail_hub6c4f78935da036f40ac595842e2051c_19420_500x0_resize_box_3.png","permalink":"/my_blog/blog/openssl_create_cert/","smallImg":"/my_blog/blog/openssl_create_cert/thumbnail_hub6c4f78935da036f40ac595842e2051c_19420_180x0_resize_box_3.png","tags":[{"title":"openssl","url":"/my_blog/tags/openssl/"},{"title":"tls","url":"/my_blog/tags/tls/"}],"timestamp":1651363200,"title":"OpenSSL - 使用 Openssl 生成 TLS 憑證"},{"content":"教你使用 Proxy 跟 HTTPS 的 3 種模式\n如何在 K8S 設定 HTTPS# 使用 Proxy 跟 HTTPS 的 3 種模式# TLS termination# nginx 把 HTTP 解密後以明文方或傳送到後方。\n設定方便，只需設定 nginx 安全性較低 TLS passthrough# nginx 不進行解密，用 TCP protocol 傳送資料到 API。\n由於 nginx 不解密，部份功能無法使用，例如修改 HTTP Header，把內容傳送到 log 系統等等 安全性比 TLS termination 高 TLS termination + TLS backend# nginx 把 HTTP 解密後，再使用 TLS 加密才傳送到後方，兩段 HTTPS。\n安全性比 TLS termination 高，比 TLS passthrough 低 nginx 可以進行解密，並使用修改 HTTP Header，log 等功能 設定繁瑣 建立 Namespace# kubectl create namespace sandbox kubectl config set-context --current --namespace=sandbox 準備憑證 Prepare Certificate# 安裝 cert manager kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml 建立 Self Sign Root CA cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: cert-manager.io/v1 kind: Issuer metadata: namespace: sandbox name: selfsigned-issuer spec: selfSigned: {} --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: namespace: sandbox name: root-ca spec: isCA: true commonName: Root CA secretName: root-ca usages: - signing - cert sign - crl sign privateKey: encoding: PKCS8 algorithm: ECDSA size: 256 issuerRef: name: selfsigned-issuer --- apiVersion: cert-manager.io/v1 kind: Issuer metadata: namespace: sandbox name: root-ca-issuer spec: ca: secretName: root-ca EOF 建立 Intermediate CA cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: cert-manager.io/v1 kind: Certificate metadata: namespace: sandbox name: inter-ca spec: isCA: true commonName: Intermediate CA secretName: inter-ca usages: - signing - cert sign - crl sign privateKey: encoding: PKCS8 algorithm: ECDSA size: 256 issuerRef: name: root-ca-issuer --- apiVersion: cert-manager.io/v1 kind: Issuer metadata: namespace: sandbox name: inter-ca-issuer spec: ca: secretName: inter-ca EOF 建立 Nginx 伺服器憑證 Nginx Server Cert cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: cert-manager.io/v1 kind: Certificate metadata: namespace: sandbox name: nginx-server-cert spec: isCA: false secretName: nginx-server-cert commonName: Nginx Server Cert dnsNames: - localhost - test-nginx-server.com - test-nginx-api-server.com usages: - digital signature - key encipherment - server auth privateKey: encoding: PKCS8 algorithm: ECDSA size: 256 issuerRef: name: inter-ca-issuer EOF 建立 API 伺服器憑證 API Server Cert cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: cert-manager.io/v1 kind: Certificate metadata: namespace: sandbox name: api-server-cert spec: isCA: false secretName: api-server-cert commonName: API Server Cert dnsNames: - localhost - test-api-server.com usages: - digital signature - key encipherment - server auth privateKey: encoding: PKCS8 algorithm: ECDSA size: 256 issuerRef: name: inter-ca-issuer EOF 可以看到已經建立了 4 個 tls secret kubectl get secret | grep tls api-server-cert kubernetes.io/tls inter-ca kubernetes.io/tls nginx-server-cert kubernetes.io/tls root-ca kubernetes.io/tls 將 Root CA 加入信任名單 # download ca cert from k8s secret kubectl get secret root-ca -o go-template=\u0026#39;{{index .data \u0026#34;ca.crt\u0026#34;|base64decode}}\u0026#39; \u0026gt; root_ca.crt # add to trusted list sudo cp root_ca.crt /usr/local/share/ca-certificates sudo update-ca-certificates 部署 api service and nginx# # deploy api service kubectl apply -f https://raw.githubusercontent.com/yip102011/isaac_test_api/master/k8s_deploy/k8s_deploy.yaml # deploy nginx kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.2.0/deploy/static/provider/cloud/deploy.yaml 部署 Ingress (TLS termination)# cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: tls-termination-ingress spec: ingressClassName: nginx tls: - hosts: - test-nginx-server.com secretName: nginx-server-cert rules: - host: test-nginx-server.com http: paths: - path: / pathType: Prefix backend: service: name: test-api port: number: 80 EOF 查看連接憑證 # 查看連接憑證 echo | openssl s_client -servername test-nginx-server.com -connect 127.0.0.1:443 | grep CN # 查看憑證詳細資料 echo | openssl s_client -servername test-nginx-server.com -connect 127.0.0.1:443 | openssl x509 -inform pem -noout -text # 可以看到已經在使用 nginx server cert 訪問 API curl --resolve test-nginx-server.com:127.0.0.1 https://test-nginx-server.com/hello Hello World!\n部署 Ingress (TLS passthrough)# # 增加 --enable-ssl-passthrough 到 container args kubectl patch deployments.apps ingress-nginx-controller -n ingress-nginx --type=json -p=\u0026#39;[{\u0026#34;op\u0026#34;: \u0026#34;add\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/spec/template/spec/containers/0/args/-\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;--enable-ssl-passthrough\u0026#34; }]\u0026#39; # 注意這次增加了 annotations # host 改成 test-api-server.com # 後台使用 443 連接 API cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: tls-passthrough-ingress annotations: nginx.ingress.kubernetes.io/ssl-passthrough: \u0026#34;true\u0026#34; spec: ingressClassName: nginx rules: - host: test-api-server.com http: paths: - path: / pathType: Prefix backend: service: name: test-api port: number: 443 EOF 查看連接憑證 # 查看連接憑證 echo | openssl s_client -servername test-api-server.com -connect 127.0.0.1:443 | grep CN # 查看憑證詳細資料 echo | openssl s_client -servername test-api-server.com -connect 127.0.0.1:443 | openssl x509 -inform pem -noout -text # 可以看到已經在使用 API server cert 訪問 API curl --resolve test-api-server.com:127.0.0.1 https://test-nginx-server.com/hello Hello World!\n部署 Ingress (TLS termination + TLS backend)# cat \u0026lt;\u0026lt;EOF | kubectl apply -f - apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: tls-termination-tls-backend-ingress annotations: nginx.ingress.kubernetes.io/backend-protocol: \u0026#34;HTTPS\u0026#34; spec: ingressClassName: nginx tls: - hosts: - test-nginx-api-server.com secretName: nginx-server-cert rules: - host: test-nginx-api-server.com http: paths: - path: / pathType: Prefix backend: service: name: test-api port: number: 443 EOF 查看連接憑證 # 查看連接憑證 echo | openssl s_client -servername test-nginx-api-server.com -connect 127.0.0.1:443 | grep CN # 查看憑證詳細資料 echo | openssl s_client -servername test-nginx-api-server.com -connect 127.0.0.1:443 | openssl x509 -inform pem -noout -text # 可以看到在使用 Nginx server cert，但後台也會用 TLS 連接API 訪問 API curl --resolve test-nginx-api-server.com:127.0.0.1 https://test-nginx-server.com/hello Hello World!\n參考文件# https://cert-manager.io/docs/installation/ ","date":"April 25, 2022","img":"/my_blog/blog/k8s_ingress_tls/thumbnail.jpeg","lang":"zh-hk","langName":"繁體中文","largeImg":"/my_blog/blog/k8s_ingress_tls/thumbnail_hue56bd63f66b9ae2896db7005e752546c_31952_500x0_resize_q75_box.jpeg","permalink":"/my_blog/blog/k8s_ingress_tls/","smallImg":"/my_blog/blog/k8s_ingress_tls/thumbnail_hue56bd63f66b9ae2896db7005e752546c_31952_180x0_resize_q75_box.jpeg","tags":[{"title":"kubernetes","url":"/my_blog/tags/kubernetes/"},{"title":"ingress-nginx","url":"/my_blog/tags/ingress-nginx/"},{"title":"tls","url":"/my_blog/tags/tls/"}],"timestamp":1650844800,"title":"K8S - TLS With Ingress Nginx"},{"content":"如何安裝 ingress-nginx\n安裝 ingress nginx# 前言# 此文章使用以下設定\nVersion Windows Windows 10 wsl2 linux Ubuntu-20.04 Docker Desktop 4.1.1(69879) Docker Kubernetes v1.21.5 要注意 ingress-nginx 由 K8S 開發. nginx-ingress 是由 nginx 開發，雖然都是用nginx作為 reverse proxy server 但設定上會有差別。\n安裝# 官網有提供各種安裝的選擇 Installation Guide - NGINX Ingress Controller (kubernetes.github.io)\n此文使用 Docker Desktop. 如果 k8s 是安裝在伺服器上，請選擇 Bare-metal.\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml 可以看到 k8s 會建立一堆資源\n用以下命令查看資源狀態，可以看到 EXTERNAL-IP 是 localhost。\nkubectl get all -n ingress-nginx Ingress controller 啟動後需要一定時間取得 EXTERNAL-IP ，如顯示 pending，請等待 1-2 分鐘。\n在 browser 輸入網址 http://localhost/ 可以看到以下畫面，代表安裝成功。\n如果 EXTERNAL-IP 一直顯示 pending，可以賞試在 Docker Desktop Troubleshoot 頁面 Reset Kubernetes cluster 然後重新啟動 Docker Desktop.\n再重新安裝 ingress-nginx.\nBare-metal ingress# 如果是使用 bare-metal，安裝在另外的伺服器上，需要自行填上自己伺服器的 IP。\nkubectl patch service ingress-nginx-controller -n ingress-nginx --patch \u0026#39;{\u0026#34;spec\u0026#34;: {\u0026#34;externalIPs\u0026#34;: [\u0026#34;172.28.240.1\u0026#34;] }}\u0026#39; 也可以安裝 MetalLB，自動分派 IP，此處不詳述。\n移除安裝# kubectl delete -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml ","date":"October 31, 2021","img":"/my_blog/blog/k8s_ingress_installation/thumbnail.jpeg","lang":"zh-hk","langName":"繁體中文","largeImg":"/my_blog/blog/k8s_ingress_installation/thumbnail_hue56bd63f66b9ae2896db7005e752546c_31952_500x0_resize_q75_box.jpeg","permalink":"/my_blog/blog/k8s_ingress_installation/","smallImg":"/my_blog/blog/k8s_ingress_installation/thumbnail_hue56bd63f66b9ae2896db7005e752546c_31952_180x0_resize_q75_box.jpeg","tags":[{"title":"kubernetes","url":"/my_blog/tags/kubernetes/"},{"title":"ingress-nginx","url":"/my_blog/tags/ingress-nginx/"}],"timestamp":1635638400,"title":"K8S - 安裝 Ingress Nginx"}]
